package org.glavo.javah

import org.objectweb.asm.ClassReader
import org.objectweb.asm.Type
import java.io.IOException
import java.io.PrintWriter
import java.nio.file.Files
import java.nio.file.Path
import java.util.*

class JNIGenerator @JvmOverloads constructor(private val outputDir: Path, searchPaths: Iterable<SearchPath>? = null, errorHandle: PrintWriter? = null) {
    private val errorHandle = errorHandle ?: Utils.NOOP_WRITER
    private val searchPaths = searchPaths ?: setOf(RuntimeSearchPath)

    fun generate(name: ClassName) {
        require(!Files.exists(outputDir) || Files.isDirectory(outputDir)) { outputDir.toString() + "is not a directory" }

        if (Files.notExists(outputDir)) {
            try {
                Files.createDirectories(outputDir)
            } catch (e: IOException) {
                errorHandle.println("error: cannot create directory $outputDir")
                e.printStackTrace(errorHandle)
                return
            }
        }

        val op = outputDir.resolve(name.mangledName + ".h")

        try {
            generateTo(name, op)
        } catch (ex: Exception) {
            errorHandle.println("error: cannot write to $op")
            ex.printStackTrace(errorHandle)
            try {
                Files.deleteIfExists(op)
            } catch (ignored: IOException) {
            }
        }
    }

    @Throws(IOException::class)
    fun generateTo(name: ClassName, outputPath: Path) {
        val meta = ClassMetaInfo()

        val inputPath = search(name)

        if (inputPath == null) {
            errorHandle.println("Not found class $name")
            return
        }

        try {
            Files.newInputStream(inputPath).use { `in` ->
                val reader = ClassReader(`in`)
                reader.accept(meta, ClassReader.SKIP_CODE or ClassReader.SKIP_DEBUG or ClassReader.SKIP_FRAMES)
            }
        } catch (e: IOException) {
            errorHandle.println("error: cannot open class file of $name")
            e.printStackTrace(errorHandle)
            errorHandle.flush()
            throw e
        }

        if (meta.methods.isEmpty() && meta.constants.isEmpty()) {
            return
        }

        PrintWriter(Files.newBufferedWriter(outputPath)).use { out ->
            out.println("/* DO NOT EDIT THIS FILE - it is machine generated */")
            out.println("#include <jni.h>")
            out.println("/* Header for class " + name.mangledName + " */")
            out.println()
            out.println("#ifndef _Included_" + name.mangledName)
            out.println("#define _Included_" + name.mangledName)
            out.println("#ifdef __cplusplus")
            out.println("extern \"C\" {")
            out.println("#endif")

            for (constant in meta.constants) {
                val cn = name.mangledName + "_" + constant.mangledName
                out.println("#undef $cn")
                out.println("#define " + cn + " " + constant.valueToString())
            }

            for (method in meta.methods) {
                val ret = mapTypeToNative(method.type.returnType)
                val args: MutableList<String> = ArrayList()
                args.add("JNIEnv *")
                args.add(if (method.isStatic) "jclass" else "jobject")
                args.addAll(listOf(*mapArgsTypeToNative(method.type)))
                val methodName = "Java_" + name.mangledName + "_" + if (meta.isOverloadMethod(method)) method.longMangledName else method.mangledName
                out.println("/*")
                out.println(" * Class:      " + name.mangledName)
                out.println(" * Method:     " + method.mangledName)
                out.println(" * Signature:  " + Utils.escape(method.type.toString()))
                out.println(" */")
                out.println("JNIEXPORT $ret JNICALL $methodName")
                out.println("  (" + java.lang.String.join(", ", args) + ");")
                out.println()
            }

            out.println("#ifdef __cplusplus")
            out.println("}")
            out.println("#endif")
            out.println("#endif")
        }
    }

    private fun search(name: ClassName): Path? {
        return SearchPath.searchFrom(searchPaths, name)
    }

    private fun mapTypeToNative(type: Type): String {
        Objects.requireNonNull(type)
        val tpe = type.toString()
        require(!tpe.startsWith("("))
        when (tpe) {
            "Z" -> return "jboolean"
            "B" -> return "jbyte"
            "C" -> return "jchar"
            "S" -> return "jshort"
            "I" -> return "jint"
            "J" -> return "jlong"
            "F" -> return "jfloat"
            "D" -> return "jdouble"
            "V" -> return "void"
            "Ljava/lang/Class;" -> return "jclass"
            "Ljava/lang/String;" -> return "jstring"
            "Ljava/lang/Throwable;" -> return "jthrowable"
            "[Z" -> return "jbooleanArray"
            "[B" -> return "jbyteArray"
            "[C" -> return "jcharArray"
            "[S" -> return "jshortArray"
            "[I" -> return "jintArray"
            "[J" -> return "jlongArray"
            "[F" -> return "jfloatArray"
            "[D" -> return "jdoubleArray"
        }
        if (tpe.startsWith("[")) {
            return "jobjectArray"
        }
        if (tpe.startsWith("L") && tpe.endsWith(";")) {
            val n = ClassName.of(tpe.substring(1, tpe.length - 1).replace('/', '.'))
            return if (isThrowable(n)) {
                "jthrowable"
            } else {
                "jobject"
            }
        }
        throw IllegalArgumentException("Unknown type: $type")
    }

    private fun mapArgsTypeToNative(methodType: Type): Array<String> {
        require(Utils.METHOD_TYPE_PATTERN.matcher(methodType.toString()).matches()) { "$methodType is not a method type" }

        val args = methodType.argumentTypes
        return Array(args.size) { i -> mapTypeToNative(args[i]) }
    }

    private fun isThrowable(name: ClassName?): Boolean {
        if (name == null) {
            return false
        }
        when (name.className) {
            "java.lang.Throwable", "java.lang.Error", "java.lang.Exception" -> return true
            "java.lang.Object" -> return false
        }
        try {
            Files.newInputStream(search(name)!!).use { `in` -> return isThrowable(Utils.superClassOf(ClassReader(`in`))) }
        } catch (ignored: Exception) {
            errorHandle.println("warning: class $name not found")
            return false
        }
    }
}
