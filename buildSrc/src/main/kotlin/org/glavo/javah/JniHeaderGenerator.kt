package org.glavo.javah

import kotlinx.metadata.KmFunction
import kotlinx.metadata.jvm.KotlinClassHeader
import kotlinx.metadata.jvm.KotlinClassMetadata
import kotlinx.metadata.jvm.signature
import org.apache.commons.lang.StringEscapeUtils
import org.objectweb.asm.ClassReader
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.MethodNode
import java.io.IOException
import java.io.PrintWriter
import java.lang.System.err
import java.nio.file.Files
import java.nio.file.Path

class JniHeaderGenerator(
    private val outputDir: Path,
    private val searchPaths: Set<SearchPath> = setOf(RuntimeSearchPath)
) {
    @Throws(IOException::class)
    fun generate(name: ClassName) {
        require(!Files.exists(outputDir) || Files.isDirectory(outputDir)) { outputDir.toString() + "is not a directory" }

        if (Files.notExists(outputDir)) {
            Files.createDirectories(outputDir)
        }

        val op = outputDir.resolve(name.mangledName + ".h")

        try {
            generateTo(name, op)
        } catch (e: Exception) {
            try {
                Files.deleteIfExists(op)
            } catch (e2: IOException) {
                e.addSuppressed(e2)
            }

            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    fun generateTo(className: ClassName, outputPath: Path) {
        val inputPath = search(className)

        if (inputPath == null) {
            err.println("Not found class $className")
            return
        }

        var constants: List<Constant> = emptyList()
        var methods: Map<String, List<Method>> = emptyMap()

        Files.newInputStream(inputPath).use { stream ->
            val reader = ClassReader(stream)

            val clazz = ClassNode()

            reader.accept(clazz, 0)

            val kmFunctions = getKotlinMetaDataClass(clazz)

            constants = getConstants(clazz)
            methods = getMethods(clazz, kmFunctions)
        }

        if (methods.isEmpty() && constants.isEmpty()) {
            return
        }

        PrintWriter(Files.newBufferedWriter(outputPath)).use { out ->
            out.println("/* DO NOT EDIT THIS FILE - it is machine generated */")
            out.println()
            out.println("#include <jni.h>")
            out.println()
            out.println("/* Header for class " + className.mangledName + " */")
            out.println()
            out.println("#ifndef _Included_" + className.mangledName)
            out.println("#define _Included_" + className.mangledName)
            out.println()
            out.println("#ifdef __cplusplus")
            out.println("extern \"C\" {")
            out.println("#endif")
            out.println()

            for (constant in constants) {
                out.println("#undef ${constant.nativeName}")
                out.println("#define ${constant.nativeName} ${constant.nativeValue}")
            }

            for (methodGroup in methods) {
                for (method in methodGroup.value) {
                    val methodName = when (methodGroup.value.size) {
                        1 -> method.nativeName
                        else -> method.nativeNameLong
                    }

                    // out.println("/*")
                    // out.println(" * Class:      " + className.mangledName)
                    // out.println(" * Method:     " + method.nativeName)
                    // out.println(" * Signature:  " + Utils.escape(method.type.toString()))
                    // out.println(" */")
                    out.print("JNIEXPORT ${method.nativeReturnType} JNICALL $methodName(")
                    out.print("JNIEnv *env")
                    if (method.static) {
                        out.print(", jclass jClass")
                    } else {
                        out.print(", jobject jThis")
                    }
                    for (argument in method.arguments) {
                        out.print(", " + argument.nativeType)
                        if (argument.nativeName != null) {
                            out.print(" " + argument.nativeName)
                        }
                    }
                    out.println(");")
                    out.println()
                }
            }

            out.println("#ifdef __cplusplus")
            out.println("}")
            out.println("#endif // __cplusplus")
            out.println()
            out.println("#endif // _Included_" + className.mangledName)
        }
    }

    private fun getMethods(clazz: ClassNode, kmFunctions: List<KmFunction>): Map<String, List<Method>> {
        return clazz
            .methods
            .asSequence()
            .filter { method -> method.access and Opcodes.ACC_NATIVE != 0 }
            .map { method ->
                val className = clazz.name.replace('/', '.')
                val name = method.name
                val static = method.access and Opcodes.ACC_STATIC != 0
                val type = Type.getType(method.desc).returnType
                Method(className, name, static, type, getArguments(method, kmFunctions))
            }
            .groupBy { method -> method.name }
    }

    private fun getConstants(clazz: ClassNode): List<Constant> {
        return clazz
            .fields
            .asSequence()
            .map { field ->
                val className = clazz.name.replace('/', '.')
                val fieldName = field.name
                return@map when (val value = field.value) {
                    is Boolean -> BooleanConstant(className, fieldName, value)
                    is Byte -> IntegerConstant(className, fieldName, value)
                    is Char -> IntegerConstant(className, fieldName, value)
                    is Double -> DoubleConstant(className, fieldName, value)
                    is Float -> FloatConstant(className, fieldName, value)
                    is Int -> IntegerConstant(className, fieldName, value)
                    is Long -> LongConstant(className, fieldName, value)
                    is Short -> IntegerConstant(className, fieldName, value)
                    is String -> StringConstant(className, fieldName, value)
                    else -> null
                }
            }
            .filterNotNull()
            .toList()
    }

    private fun getKotlinMetaDataClass(clazz: ClassNode): List<KmFunction> {
        return clazz
            .visibleAnnotations
            .find { Type.getType(it.desc).className == "kotlin.Metadata" }
            ?.let { annotation ->
                val values = annotation
                    .values
                    .windowed(size = 2, step = 2)
                    .map<List<Any>, Pair<Any, Any>> { it[0] to it[1] }
                    .toMap<Any?, Any?>()

                @Suppress("UNCHECKED_CAST")
                val header = KotlinClassHeader(
                    values["k"] as? Int,
                    (values["mv"] as? ArrayList<Int>)?.toIntArray(),
                    (values["bv"] as? ArrayList<Int>)?.toIntArray(),
                    (values["d1"] as? ArrayList<String>)?.toTypedArray(),
                    (values["d2"] as? ArrayList<String>)?.toTypedArray(),
                    values["xs"] as? String,
                    values["pn"] as? String,
                    values["xi"] as? Int
                )

                when (val metadata = KotlinClassMetadata.read(header)) {
                    is KotlinClassMetadata.Class -> metadata.toKmClass().functions
                    is KotlinClassMetadata.FileFacade -> metadata.toKmPackage().functions
                    is KotlinClassMetadata.SyntheticClass -> metadata.toKmLambda()?.let { lambda -> listOf(lambda.function) }
                    is KotlinClassMetadata.MultiFileClassFacade -> null
                    is KotlinClassMetadata.MultiFileClassPart -> metadata.toKmPackage().functions
                    is KotlinClassMetadata.Unknown -> null
                    null -> null
                }
            }
            ?: emptyList()
    }

    private fun search(name: ClassName): Path? {
        return SearchPath.searchFrom(searchPaths, name)
    }

    private fun mapTypeToNative(type: Type): String {
        val typeName = type.toString()
        require(!typeName.startsWith("("))
        when (typeName) {
            "Z" -> return "jboolean"
            "B" -> return "jbyte"
            "C" -> return "jchar"
            "S" -> return "jshort"
            "I" -> return "jint"
            "J" -> return "jlong"
            "F" -> return "jfloat"
            "D" -> return "jdouble"
            "V" -> return "void"
            "Ljava/lang/Class;" -> return "jclass"
            "Ljava/lang/String;" -> return "jstring"
            "Ljava/lang/Throwable;" -> return "jthrowable"
            "[Z" -> return "jbooleanArray"
            "[B" -> return "jbyteArray"
            "[C" -> return "jcharArray"
            "[S" -> return "jshortArray"
            "[I" -> return "jintArray"
            "[J" -> return "jlongArray"
            "[F" -> return "jfloatArray"
            "[D" -> return "jdoubleArray"
        }

        if (typeName.startsWith("[")) {
            return "jobjectArray"
        }
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            val n = ClassName.of(typeName.substring(1, typeName.length - 1).replace('/', '.'))
            return if (isThrowable(n)) {
                "jthrowable"
            } else {
                "jobject"
            }
        }
        throw IllegalArgumentException("Unknown type: $type")
    }

    private fun mapArgsTypeToNative(methodType: Type): Array<String> {
        require(Utils.METHOD_TYPE_PATTERN.matches(methodType.toString())) { "$methodType is not a method type" }

        val args = methodType.argumentTypes
        return Array(args.size) { i -> mapTypeToNative(args[i]) }
    }

    private fun isThrowable(name: ClassName?): Boolean {
        if (name == null) {
            return false
        }

        when (name.className) {
            "java.lang.Throwable", "java.lang.Error", "java.lang.Exception" -> return true
            "java.lang.Object", "java.lang.Enum" -> return false
        }
        try {
            Files.newInputStream(search(name)!!).use { `in` -> return isThrowable(Utils.superClassOf(ClassReader(`in`))) }
        } catch (ignored: Exception) {
            err.println("warning: class $name not found")
            return false
        }
    }

    inner class Method(
        className: String,
        val name: String,
        val static: Boolean,
        returnType: Type,
        val arguments: List<Argument>
    ) {
        val nativeName = "Java_" + Utils.mangleName(className) + "_" + Utils.mangleName(name)

        val nativeNameLong by lazy {
            val argumentSignature = arguments
                .asSequence()
                .map { it.type.descriptor }
                .joinToString(separator = "")

            nativeName + "__" + Utils.mangleName(argumentSignature)
        }

        val nativeReturnType = mapTypeToNative(returnType)

    }

    inner class Argument(val type: Type, name: String?) {
        val nativeType = mapTypeToNative(type)
        val nativeName = name?.let { 'j' + name.capitalize() }
    }

    private fun getArguments(method: MethodNode, kmFunctions: List<KmFunction>): List<Argument> {
        val types = Type.getType(method.desc).argumentTypes
        var names: List<String?>?

        // Try Kotlin @Metadata annotation
        names = kmFunctions
            .firstOrNull { function ->
                function.name == method.name.substringBefore('-')
                        && function.signature!!.desc == method.desc
            }
            ?.let { it ->
                val parameterNames = it.valueParameters.asSequence().map { it.name }
                if (it.receiverParameterType == null) {
                    parameterNames
                } else {
                    sequenceOf("receiver") + parameterNames
                }
            }
            ?.toList()

        // TODO: get names from asm

        names = types.indices.map { names?.get(it) }

        return types.zip(names)
            .map { (type, name) -> Argument(type, name) }
    }
}

sealed class Constant(className: String, name: String) {
    val nativeName: String = Utils.mangleName(className) + '_' + Utils.mangleName(name)
    abstract val nativeValue: String
}

class BooleanConstant(className: String, fieldName: String, value: Boolean) : Constant(className, fieldName) {
    override val nativeValue = "$value"
}

class IntegerConstant(className: String, fieldName: String, value: Int) : Constant(className, fieldName) {
    constructor(className: String, fieldName: String, value: Byte) : this(className, fieldName, value.toInt())
    constructor(className: String, fieldName: String, value: Char) : this(className, fieldName, value.toInt())
    constructor(className: String, fieldName: String, value: Short) : this(className, fieldName, value.toInt())

    override val nativeValue = "${value}L"
}

class DoubleConstant(className: String, fieldName: String, value: Double) : Constant(className, fieldName) {
    override val nativeValue = "$value"
}

class FloatConstant(className: String, fieldName: String, value: Float) : Constant(className, fieldName) {
    override val nativeValue = "${value}F"
}

class StringConstant(className: String, fieldName: String, value: String) : Constant(className, fieldName) {
    override val nativeValue = "\"${StringEscapeUtils.escapeJava(value)}\""
}

class LongConstant(className: String, fieldName: String, value: Long) : Constant(className, fieldName) {
    override val nativeValue = "${value}i64"
}
